#!/usr/bin/sudo bpftrace

// Each power of 2 will be split into 2^HIST_EXTRA_BUCKETS linear sub-buckets.
#define HIST_EXTRA_BUCKETS 1

// Specifies whether the script should create the histogram with string keys,
// causes `misaligned stack access off` error on some bpftrace versions.
#define USE_STR 0

BEGIN {
  if (USE_STR) {
    @ioopcode[0x00] = "flush";
    @ioopcode[0x01] = "write";
    @ioopcode[0x02] = "read";
    @ioopcode[0x04] = "write_uncor";
    @ioopcode[0x05] = "compare";
    @ioopcode[0x08] = "write_zeroes";
    @ioopcode[0x09] = "dsm";
    @ioopcode[0x0d] = "resv_register";
    @ioopcode[0x0e] = "resv_report";
    @ioopcode[0x11] = "resv_acquire";
    @ioopcode[0x15] = "resv_release";
  }
}

tracepoint:nvme:nvme_setup_cmd /args->qid > 0/ {
    /*
     * Get number of logical blocks (NLB) from cdw12.
     * cdw12 is bytes 8,9,10,11 in the args->cdw10[24] array.
     * We must reconstruct the u32 from four u8s (assuming little-endian).
     */
    $nlb_b0 = args->cdw10[8];
    $nlb_b1 = args->cdw10[9];
    $nlb_b2 = args->cdw10[10];
    $nlb_b3 = args->cdw10[11];
    $nlb = ($nlb_b3 << 24) | ($nlb_b2 << 16) | ($nlb_b1 << 8) | $nlb_b0;

    $nlb++;

    @start_info[args->ctrl_id, args->qid, args->cid] = 
        (nsecs, args->opcode, $nlb);
}

tracepoint:nvme:nvme_complete_rq 
/@start_info[args->ctrl_id, args->qid, args->cid].0/ {
  $start_tuple = @start_info[args->ctrl_id, args->qid, args->cid];
  $start_ns = $start_tuple.0;
  $opcode = $start_tuple.1;
  $nlb = $start_tuple.2;

  $latency_us = (nsecs - $start_ns) / 1000;

  if (USE_STR) {
    // Assuming LBA size of 4K.
    $nlb_str = "";
    if ($nlb <=  4) {
      $nlb_str = "<=16K";
    } else if ($nlb <= 16) {
      $nlb_str = "<=64K";
    } else {
      $nlb_str = " >64K"
    }
    if ($opcode == 0) {
      // Flush does not have NLB.
      $nlb_str = "-";
    }
    @latency_hist_str[args->ctrl_id, @ioopcode[$opcode], $nlb_str] = 
        hist($latency_us, HIST_EXTRA_BUCKETS);
  } else {
    $nlb_class = 0;
    if ($nlb > 16) {
      $nlb_class = 2;
    } else if ($nlb > 4) {
      $nlb_class = 1;
    } 
    @latency_hist[args->ctrl_id, $opcode, $nlb_class] = 
        hist($latency_us, HIST_EXTRA_BUCKETS);
  }

  delete(@start_info[args->ctrl_id, args->qid, args->cid]);
}

END {
  clear(@start_info);
  clear(@ioopcode);
}

/*
cat /sys/kernel/debug/tracing/events/nvme/nvme_setup_cmd/format
name: nvme_setup_cmd
ID: 1503
format:
	field:unsigned short common_type;	offset:0;	size:2;	signed:0;
	field:unsigned char common_flags;	offset:2;	size:1;	signed:0;
	field:unsigned char common_preempt_count;	offset:3;	size:1;	signed:0;
	field:int common_pid;	offset:4;	size:4;	signed:1;

	field:char disk[32];	offset:8;	size:32;	signed:0;
	field:int ctrl_id;	offset:40;	size:4;	signed:1;
	field:int qid;	offset:44;	size:4;	signed:1;
	field:u8 opcode;	offset:48;	size:1;	signed:0;
	field:u8 flags;	offset:49;	size:1;	signed:0;
	field:u8 fctype;	offset:50;	size:1;	signed:0;
	field:u16 cid;	offset:52;	size:2;	signed:0;
	field:u32 nsid;	offset:56;	size:4;	signed:0;
	field:bool metadata;	offset:60;	size:1;	signed:0;
	field:u8 cdw10[24];	offset:61;	size:24;	signed:0;

print fmt: "nvme%d: %sqid=%d, cmdid=%u, nsid=%u, flags=0x%x, meta=0x%x, cmd=(%s %s)", REC->ctrl_id, nvme_trace_disk_name(p, REC->disk), REC->qid, REC->cid, REC->nsid, REC->flags, REC->metadata, ((REC->opcode) == nvme_fabrics_command ? __print_symbolic(REC->fctype, { nvme_fabrics_type_property_set, "nvme_fabrics_type_property_set" }, { nvme_fabrics_type_connect, "nvme_fabrics_type_connect" }, { nvme_fabrics_type_property_get, "nvme_fabrics_type_property_get" }, { nvme_fabrics_type_auth_send, "nvme_fabrics_type_auth_send" }, { nvme_fabrics_type_auth_receive, "nvme_fabrics_type_auth_receive" }) : ((REC->qid) ? __print_symbolic(REC->opcode, { nvme_cmd_flush, "nvme_cmd_flush" }, { nvme_cmd_write, "nvme_cmd_write" }, { nvme_cmd_read, "nvme_cmd_read" }, { nvme_cmd_write_uncor, "nvme_cmd_write_uncor" }, { nvme_cmd_compare, "nvme_cmd_compare" }, { nvme_cmd_write_zeroes, "nvme_cmd_write_zeroes" }, { nvme_cmd_dsm, "nvme_cmd_dsm" }, { nvme_cmd_verify, "nvme_cmd_verify" }, { nvme_cmd_resv_register, "nvme_cmd_resv_register" }, { nvme_cmd_resv_report, "nvme_cmd_resv_report" }, { nvme_cmd_resv_acquire, "nvme_cmd_resv_acquire" }, { nvme_cmd_resv_release, "nvme_cmd_resv_release" }, { nvme_cmd_zone_mgmt_send, "nvme_cmd_zone_mgmt_send" }, { nvme_cmd_zone_mgmt_recv, "nvme_cmd_zone_mgmt_recv" }, { nvme_cmd_zone_append, "nvme_cmd_zone_append" }) : __print_symbolic(REC->opcode, { nvme_admin_delete_sq, "nvme_admin_delete_sq" }, { nvme_admin_create_sq, "nvme_admin_create_sq" }, { nvme_admin_get_log_page, "nvme_admin_get_log_page" }, { nvme_admin_delete_cq, "nvme_admin_delete_cq" }, { nvme_admin_create_cq, "nvme_admin_create_cq" }, { nvme_admin_identify, "nvme_admin_identify" }, { nvme_admin_abort_cmd, "nvme_admin_abort_cmd" }, { nvme_admin_set_features, "nvme_admin_set_features" }, { nvme_admin_get_features, "nvme_admin_get_features" }, { nvme_admin_async_event, "nvme_admin_async_event" }, { nvme_admin_ns_mgmt, "nvme_admin_ns_mgmt" }, { nvme_admin_activate_fw, "nvme_admin_activate_fw" }, { nvme_admin_download_fw, "nvme_admin_download_fw" }, { nvme_admin_dev_self_test, "nvme_admin_dev_self_test" }, { nvme_admin_ns_attach, "nvme_admin_ns_attach" }, { nvme_admin_keep_alive, "nvme_admin_keep_alive" }, { nvme_admin_directive_send, "nvme_admin_directive_send" }, { nvme_admin_directive_recv, "nvme_admin_directive_recv" }, { nvme_admin_virtual_mgmt, "nvme_admin_virtual_mgmt" }, { nvme_admin_nvme_mi_send, "nvme_admin_nvme_mi_send" }, { nvme_admin_nvme_mi_recv, "nvme_admin_nvme_mi_recv" }, { nvme_admin_dbbuf, "nvme_admin_dbbuf" }, { nvme_admin_format_nvm, "nvme_admin_format_nvm" }, { nvme_admin_security_send, "nvme_admin_security_send" }, { nvme_admin_security_recv, "nvme_admin_security_recv" }, { nvme_admin_sanitize_nvm, "nvme_admin_sanitize_nvm" }, { nvme_admin_get_lba_status, "nvme_admin_get_lba_status" }))), ((REC->opcode) == nvme_fabrics_command ? nvme_trace_parse_fabrics_cmd(p, REC->fctype, REC->cdw10) : ((REC->qid) ? nvme_trace_parse_nvm_cmd(p, REC->opcode, REC->cdw10) : nvme_trace_parse_admin_cmd(p, REC->opcode, REC->cdw10)))

cat /sys/kernel/debug/tracing/events/nvme/nvme_complete_rq/format
name: nvme_complete_rq
ID: 1502
format:
	field:unsigned short common_type;	offset:0;	size:2;	signed:0;
	field:unsigned char common_flags;	offset:2;	size:1;	signed:0;
	field:unsigned char common_preempt_count;	offset:3;	size:1;	signed:0;
	field:int common_pid;	offset:4;	size:4;	signed:1;

	field:char disk[32];	offset:8;	size:32;	signed:0;
	field:int ctrl_id;	offset:40;	size:4;	signed:1;
	field:int qid;	offset:44;	size:4;	signed:1;
	field:int cid;	offset:48;	size:4;	signed:1;
	field:u64 result;	offset:56;	size:8;	signed:0;
	field:u8 retries;	offset:64;	size:1;	signed:0;
	field:u8 flags;	offset:65;	size:1;	signed:0;
	field:u16 status;	offset:66;	size:2;	signed:0;

print fmt: "nvme%d: %sqid=%d, cmdid=%u, res=%#llx, retries=%u, flags=0x%x, status=%#x", REC->ctrl_id, nvme_trace_disk_name(p, REC->disk), REC->qid, REC->cid, REC->result, REC->retries, REC->flags, REC->status
*/


