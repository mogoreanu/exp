#!/usr/bin/bpftrace

#include <linux/blkdev.h>
#include <linux/nvme.h>
#include <linux/nvme_ioctl.h>
#include <linux/cdev.h>

struct nvme_fault_inject {
#ifdef CONFIG_FAULT_INJECTION_DEBUG_FS
  struct fault_attr attr;
  struct dentry *parent;
  bool dont_retry;  /* DNR, do not retry */
  u16 status;    /* status code */
#endif
};

// This struct is in `linux/drivers/nvme/host/nvme.h` which is, apparently, not
// available in BPF, copy it here for now.
struct nvme_ns {
  struct list_head list;

  struct nvme_ctrl *ctrl;
  struct request_queue *queue;
  struct gendisk *disk;
#ifdef CONFIG_NVME_MULTIPATH
  enum nvme_ana_state ana_state;
  u32 ana_grpid;
#endif
  struct list_head siblings;
  struct kref kref;
  struct nvme_ns_head *head;

  unsigned long flags;
#define NVME_NS_REMOVING    0
#define NVME_NS_ANA_PENDING    2
#define NVME_NS_FORCE_RO    3
#define NVME_NS_READY      4
#define NVME_NS_SYSFS_ATTR_LINK  5

  struct cdev    cdev;
  struct device    cdev_device;

  struct nvme_fault_inject fault_inject;
};

struct nvme_request {
	struct nvme_command	*cmd;
	union nvme_result	result;
	u8			genctr;
	u8			retries;
	u8			flags;
	u16			status;
#ifdef CONFIG_NVME_MULTIPATH
	unsigned long		start_time;
#endif
	struct nvme_ctrl	*ctrl;
};

#define VLOG false

BEGIN {
  printf("Tracing nvme command latency. Hit Ctrl-C to end.\n");
  @vlog = false;

	@ioopcode[0x00] = "nvme_cmd_flush";
	@ioopcode[0x01] = "nvme_cmd_write";
	@ioopcode[0x02] = "nvme_cmd_read";
	@ioopcode[0x04] = "nvme_cmd_write_uncor";
	@ioopcode[0x05] = "nvme_cmd_compare";
	@ioopcode[0x08] = "nvme_cmd_write_zeroes";
	@ioopcode[0x09] = "nvme_cmd_dsm";
	@ioopcode[0x0d] = "nvme_cmd_resv_register";
	@ioopcode[0x0e] = "nvme_cmd_resv_report";
	@ioopcode[0x11] = "nvme_cmd_resv_acquire";
	@ioopcode[0x15] = "nvme_cmd_resv_release";
}

// Save the arguments to be able to access them in kretprobe. This pain is not
// necessary in kfunc / kretfunc, but not all kernels have that.
kprobe:nvme_setup_cmd {
  @args_map[tid, 0] = arg0;  // struct nvme_ns *ns
  @args_map[tid, 1] = arg1;  // struct request *req
}

// Bind to `nvme_setup_cmd` return because the command_id field is populated in 
// the method itself. Strictly speaking not necessary for latency accounting.
kretprobe:nvme_setup_cmd {
  $ns = (struct nvme_ns*)@args_map[tid, 0]; // args.ns;
  $req = (struct request*)@args_map[tid, 1]; // args.req;
  delete(@args_map[tid, 0]);
  delete(@args_map[tid, 1]);
  $req_end = $req + 1;
  $nvme_req = (struct nvme_request *)$req_end;
  $nvme_cmd = (struct nvme_command *)$nvme_req->cmd;
  if (VLOG) {
    printf("kfunc:vmlinux:nvme_setup_cmd disk_name: %s opcode: %x cid: %d.\n", 
             $ns->disk->disk_name, $nvme_cmd->common.opcode, 
                   $nvme_cmd->common.command_id);
  }
  @in_flight_req[$req] = nsecs;

}

// void nvme_complete_batch_req(struct request *req)
// Intercept only when there's a corresponding start entry.
// TODO(mogo): /has_key(@in_flight_req, args.req)/ doesn't seem to work.
kprobe:nvme_complete_batch_req,kprobe:nvme_complete_rq /@in_flight_req[(struct request*)arg0]/ {
  $req = (struct request*)arg0; // args.req;
  $req_end = $req + 1;
  $nvme_req = (struct nvme_request *)$req_end;
  $nvme_cmd = (struct nvme_command *)$nvme_req->cmd;
  if (VLOG) {
    printf("kfunc:vmlinux:nvme_complete_batch_req opcode: %x cid: %d.\n",
           $nvme_cmd->common.opcode, $nvme_cmd->common.command_id);
  }
  @req_lat_us = hist((nsecs - @in_flight_req[$req]) / 1000);
  delete(@in_flight_req[$req]);
}


END {
  clear(@args_map); 
  clear(@in_flight_req); 
  clear(@ioopcode)
}